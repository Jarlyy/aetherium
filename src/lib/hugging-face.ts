import { HfInference } from '@huggingface/inference';
import type { HuggingFaceResponse } from '@/types/model';

// Инициализация Hugging Face клиента
const hf = new HfInference(process.env.HUGGING_FACE_API_TOKEN);

// Константы моделей
export const MODELS = {
  HUNYUAN_3D: 'tencent/Hunyuan3D-2.1',
  QWEN_IMAGE: 'Qwen/Qwen2-VL-7B-Instruct',
  // Альтернативные модели для тестирования
  TEXT_TO_IMAGE: 'stabilityai/stable-diffusion-xl-base-1.0',
  IMAGE_TO_3D: 'ashawkey/shap-e-img'
} as const;

/**
 * Генерация изображения из текста с помощью Qwen
 */
export async function generateImageFromText(prompt: string): Promise<Blob> {
  try {
    console.log('Generating image with prompt:', prompt);
    
    // Используем text-to-image модель для генерации изображения
    const response: any = await hf.textToImage({
      model: MODELS.TEXT_TO_IMAGE,
      inputs: prompt,
      parameters: {
        negative_prompt: "blurry, low quality, distorted",
        num_inference_steps: 30,
        guidance_scale: 7.5,
      }
    });

    // Проверяем, что response является Blob
    if (response instanceof Blob) {
      return response;
    } else {
      // Преобразуем в Blob если нужно
      return new Blob([response], { type: 'image/jpeg' });
    }
  } catch (error) {
    console.error('Error generating image:', error);
    
    // В случае ошибки создаем placeholder SVG
    const placeholderSvg = `<svg width="400" height="400" xmlns="http://www.w3.org/2000/svg">
      <rect width="400" height="400" fill="#2a2a2a"/>
      <circle cx="200" cy="200" r="80" fill="#3b82f6" stroke="#60a5fa" stroke-width="3"/>
      <text x="200" y="320" text-anchor="middle" fill="#9ca3af" font-family="Arial" font-size="16">Generated Image</text>
      <text x="200" y="340" text-anchor="middle" fill="#6b7280" font-family="Arial" font-size="12">${prompt.substring(0, 30)}...</text>
    </svg>`;
    
    return new Blob([placeholderSvg], { type: 'image/svg+xml' });
  }
}

/**
 * Генерация 3D модели из текста (улучшенная версия)
 * В реальной реализации нужно использовать Hunyuan3D API
 */
export async function generate3DFromText(prompt: string): Promise<{ modelFile: Blob; previewImage: Blob }> {
  try {
    console.log('Generating 3D model with prompt:', prompt);
    
    // Пока Hunyuan3D API сложно интегрировать, создаем улучшенную mock-реализацию
    // Сначала генерируем изображение концепта
    const previewImage = await generateImageFromText(`3D model concept: ${prompt}, isometric view, clean background`);
    
    // Создаем более сложную 3D модель на основе промпта
    const objContent = generateObjByPrompt(prompt);
    
    const modelFile = new Blob([objContent], { type: 'text/plain' });
    
    return {
      modelFile,
      previewImage
    };
  } catch (error) {
    console.error('Error generating 3D model:', error);
    throw new Error(`Ошибка генерации 3D модели: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Генерация OBJ файла на основе промпта
 */
function generateObjByPrompt(prompt: string): string {
  const lowerPrompt = prompt.toLowerCase();
  
  // Определяем тип объекта по ключевым словам
  if (lowerPrompt.includes('стул') || lowerPrompt.includes('chair')) {
    return generateChairObj(prompt);
  } else if (lowerPrompt.includes('стол') || lowerPrompt.includes('table')) {
    return generateTableObj(prompt);
  } else if (lowerPrompt.includes('ваза') || lowerPrompt.includes('vase') || lowerPrompt.includes('кувшин')) {
    return generateVaseObj(prompt);
  } else if (lowerPrompt.includes('дом') || lowerPrompt.includes('house') || lowerPrompt.includes('домик')) {
    return generateHouseObj(prompt);
  } else if (lowerPrompt.includes('сфера') || lowerPrompt.includes('шар') || lowerPrompt.includes('sphere')) {
    return generateSphereObj(prompt);
  } else if (lowerPrompt.includes('пирамида') || lowerPrompt.includes('pyramid')) {
    return generatePyramidObj(prompt);
  } else {
    // По умолчанию - куб, но улучшенный
    return generateCubeObj(prompt);
  }
}

/**
 * Генерация стула
 */
function generateChairObj(prompt: string): string {
  return `# OBJ Chair generated for: ${prompt}
# Generated by Aetherium

# Сиденье стула
v -0.5 0.5 -0.5
v 0.5 0.5 -0.5
v 0.5 0.5 0.5
v -0.5 0.5 0.5
v -0.5 0.4 -0.5
v 0.5 0.4 -0.5
v 0.5 0.4 0.5
v -0.5 0.4 0.5

# Спинка стула
v -0.5 1.2 -0.4
v 0.5 1.2 -0.4
v 0.5 0.5 -0.4
v -0.5 0.5 -0.4
v -0.5 1.2 -0.5
v 0.5 1.2 -0.5
v 0.5 0.5 -0.5
v -0.5 0.5 -0.5

# Ножки стула
v -0.4 0.0 -0.4
v -0.3 0.0 -0.4
v -0.3 0.4 -0.4
v -0.4 0.4 -0.4
v 0.3 0.0 -0.4
v 0.4 0.0 -0.4
v 0.4 0.4 -0.4
v 0.3 0.4 -0.4
v -0.4 0.0 0.3
v -0.3 0.0 0.3
v -0.3 0.4 0.3
v -0.4 0.4 0.3
v 0.3 0.0 0.3
v 0.4 0.0 0.3
v 0.4 0.4 0.3
v 0.3 0.4 0.3

# Грани сиденья
f 1 2 3 4
f 8 7 6 5
f 1 5 6 2
f 2 6 7 3
f 3 7 8 4
f 4 8 5 1

# Грани спинки
f 9 10 11 12
f 16 15 14 13
f 9 13 14 10
f 10 14 15 11
f 11 15 16 12
f 12 16 13 9

# Ножки
f 17 18 19 20
f 21 22 23 24
f 25 26 27 28
f 29 30 31 32`;
}

/**
 * Генерация стола
 */
function generateTableObj(prompt: string): string {
  return `# OBJ Table generated for: ${prompt}
# Generated by Aetherium

# Столешница
v -1.0 0.8 -0.6
v 1.0 0.8 -0.6
v 1.0 0.8 0.6
v -1.0 0.8 0.6
v -1.0 0.7 -0.6
v 1.0 0.7 -0.6
v 1.0 0.7 0.6
v -1.0 0.7 0.6

# Ножки стола
v -0.8 0.0 -0.4
v -0.7 0.0 -0.4
v -0.7 0.7 -0.4
v -0.8 0.7 -0.4
v 0.7 0.0 -0.4
v 0.8 0.0 -0.4
v 0.8 0.7 -0.4
v 0.7 0.7 -0.4
v -0.8 0.0 0.4
v -0.7 0.0 0.4
v -0.7 0.7 0.4
v -0.8 0.7 0.4
v 0.7 0.0 0.4
v 0.8 0.0 0.4
v 0.8 0.7 0.4
v 0.7 0.7 0.4

# Грани столешницы
f 1 2 3 4
f 8 7 6 5
f 1 5 6 2
f 2 6 7 3
f 3 7 8 4
f 4 8 5 1

# Ножки
f 9 10 11 12
f 13 14 15 16
f 17 18 19 20
f 21 22 23 24`;
}

/**
 * Генерация вазы
 */
function generateVaseObj(prompt: string): string {
  // Создаем вазу с помощью вращения профиля
  const vertices = [];
  const faces = [];
  let vertexIndex = 1;
  
  // Профиль вазы (радиус на разных высотах)
  const profile = [
    {h: 0.0, r: 0.3},   // Дно
    {h: 0.2, r: 0.4},   // Расширение
    {h: 0.4, r: 0.35},  // Сужение
    {h: 0.6, r: 0.4},   // Расширение
    {h: 0.8, r: 0.3},   // Сужение к горлышку
    {h: 1.0, r: 0.25}   // Горлышко
  ];
  
  const segments = 12; // Количество сегментов вращения
  
  // Генерируем вершины
  for (let i = 0; i < profile.length; i++) {
    for (let j = 0; j < segments; j++) {
      const angle = (j / segments) * 2 * Math.PI;
      const x = profile[i].r * Math.cos(angle);
      const z = profile[i].r * Math.sin(angle);
      const y = profile[i].h;
      vertices.push(`v ${x.toFixed(3)} ${y.toFixed(3)} ${z.toFixed(3)}`);
    }
  }
  
  return `# OBJ Vase generated for: ${prompt}
# Generated by Aetherium

${vertices.join('\n')}

# Боковые грани
${generateVaseFaces(profile.length, segments)}`;
}

function generateVaseFaces(levels: number, segments: number): string {
  const faces = [];
  
  for (let i = 0; i < levels - 1; i++) {
    for (let j = 0; j < segments; j++) {
      const current = i * segments + j + 1;
      const next = i * segments + ((j + 1) % segments) + 1;
      const currentUp = (i + 1) * segments + j + 1;
      const nextUp = (i + 1) * segments + ((j + 1) % segments) + 1;
      
      // Два треугольника для каждого квада
      faces.push(`f ${current} ${next} ${nextUp} ${currentUp}`);
    }
  }
  
  return faces.join('\n');
}

/**
 * Генерация дома
 */
function generateHouseObj(prompt: string): string {
  return `# OBJ House generated for: ${prompt}
# Generated by Aetherium

# Основание дома
v -1.0 0.0 -1.0
v 1.0 0.0 -1.0
v 1.0 0.0 1.0
v -1.0 0.0 1.0
v -1.0 1.0 -1.0
v 1.0 1.0 -1.0
v 1.0 1.0 1.0
v -1.0 1.0 1.0

# Крыша
v -1.2 1.0 -1.2
v 1.2 1.0 -1.2
v 1.2 1.0 1.2
v -1.2 1.0 1.2
v 0.0 1.8 0.0

# Дверь
v -0.2 0.0 1.0
v 0.2 0.0 1.0
v 0.2 0.8 1.0
v -0.2 0.8 1.0

# Окно
v -0.6 0.3 1.0
v -0.4 0.3 1.0
v -0.4 0.6 1.0
v -0.6 0.6 1.0

# Стены дома
f 1 2 6 5
f 2 3 7 6
f 3 4 8 7
f 4 1 5 8
f 5 6 7 8
f 4 3 2 1

# Крыша
f 9 10 13
f 10 11 13
f 11 12 13
f 12 9 13
f 9 12 11 10

# Дверь
f 14 15 16 17

# Окно
f 18 19 20 21`;
}

/**
 * Генерация сферы
 */
function generateSphereObj(prompt: string): string {
  const vertices = [];
  const faces = [];
  const radius = 0.5;
  const stacks = 8;
  const slices = 12;
  
  // Генерируем вершины сферы
  for (let i = 0; i <= stacks; i++) {
    const phi = Math.PI * i / stacks;
    for (let j = 0; j <= slices; j++) {
      const theta = 2 * Math.PI * j / slices;
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      vertices.push(`v ${x.toFixed(3)} ${y.toFixed(3)} ${z.toFixed(3)}`);
    }
  }
  
  // Генерируем грани
  for (let i = 0; i < stacks; i++) {
    for (let j = 0; j < slices; j++) {
      const first = i * (slices + 1) + j + 1;
      const second = first + slices + 1;
      
      faces.push(`f ${first} ${first + 1} ${second + 1} ${second}`);
    }
  }
  
  return `# OBJ Sphere generated for: ${prompt}
# Generated by Aetherium

${vertices.join('\n')}

${faces.join('\n')}`;
}

/**
 * Генерация пирамиды
 */
function generatePyramidObj(prompt: string): string {
  return `# OBJ Pyramid generated for: ${prompt}
# Generated by Aetherium

# Основание пирамиды
v -1.0 0.0 -1.0
v 1.0 0.0 -1.0
v 1.0 0.0 1.0
v -1.0 0.0 1.0

# Вершина пирамиды
v 0.0 1.5 0.0

# Основание
f 4 3 2 1

# Боковые грани
f 1 2 5
f 2 3 5
f 3 4 5
f 4 1 5`;
}

/**
 * Генерация улучшенного куба
 */
function generateCubeObj(prompt: string): string {
  return `# OBJ Cube generated for: ${prompt}
# Generated by Aetherium

# 8 вершин куба
v -0.5 -0.5 -0.5
v 0.5 -0.5 -0.5
v 0.5 0.5 -0.5
v -0.5 0.5 -0.5
v -0.5 -0.5 0.5
v 0.5 -0.5 0.5
v 0.5 0.5 0.5
v -0.5 0.5 0.5

# 6 граней куба
f 1 2 3 4
f 8 7 6 5
f 1 5 6 2
f 2 6 7 3
f 3 7 8 4
f 4 8 5 1`;
}

/**
 * Улучшение промпта для лучших результатов
 */
export function enhancePrompt(prompt: string): string {
  const enhancements = [
    "high quality 3D model",
    "detailed geometry",
    "clean topology",
    "professional rendering"
  ];
  
  return `${prompt}, ${enhancements.join(', ')}`;
}

/**
 * Проверка доступности Hugging Face API
 */
export async function checkHuggingFaceConnection(): Promise<boolean> {
  try {
    // Простой тест API с минимальным запросом
    await hf.textGeneration({
      model: 'gpt2',
      inputs: 'test',
      parameters: { max_new_tokens: 1 }
    });
    return true;
  } catch (error) {
    console.error('Hugging Face API connection failed:', error);
    return false;
  }
}

/**
 * Получение статуса модели
 */
export async function getModelStatus(modelName: string): Promise<'loaded' | 'loading' | 'error'> {
  try {
    // Проверяем доступность модели
    const response = await fetch(`https://huggingface.co/api/models/${modelName}`);
    if (response.ok) {
      return 'loaded';
    }
    return 'error';
  } catch (error) {
    console.error('Error checking model status:', error);
    return 'error';
  }
}