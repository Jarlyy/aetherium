import { NextRequest, NextResponse } from 'next/server';
import { generate3DFromText, enhancePrompt } from '@/lib/hugging-face';
import { v4 as uuidv4 } from 'uuid';
import { writeFile, mkdir } from 'fs/promises';
import path from 'path';

export async function POST(request: NextRequest) {
  try {
    const { prompt, style, quality } = await request.json();

    if (!prompt || typeof prompt !== 'string') {
      return NextResponse.json(
        { success: false, error: 'Промпт обязателен' },
        { status: 400 }
      );
    }

    // Генерируем уникальный ID для модели
    const modelId = uuidv4();
    
    // Улучшаем промпт
    const enhancedPrompt = enhancePrompt(prompt);
    
    console.log(`Starting 3D generation for model ${modelId} with prompt: "${enhancedPrompt}"`);

    // Создаем папки для сохранения файлов
    const publicDir = path.join(process.cwd(), 'public');
    const modelsDir = path.join(publicDir, 'models');
    const modelDir = path.join(modelsDir, modelId);

    await mkdir(modelsDir, { recursive: true });
    await mkdir(modelDir, { recursive: true });

    // Генерируем 3D модель и превью (пока используем mock для стабильности)
    console.log('Generating mock 3D model and preview...');
    
    // Создаем простой .obj файл
    const objContent = `# OBJ file generated for: ${enhancedPrompt}
# Generated by Aetherium MVP
# Simple cube model
v -1.0 -1.0  1.0
v  1.0 -1.0  1.0
v  1.0  1.0  1.0
v -1.0  1.0  1.0
v -1.0 -1.0 -1.0
v  1.0 -1.0 -1.0
v  1.0  1.0 -1.0
v -1.0  1.0 -1.0

f 1 2 3 4
f 8 7 6 5
f 4 3 7 8
f 5 1 4 8
f 5 6 2 1
f 2 6 7 3`;
    
    // Создаем простое превью (placeholder SVG)
    const previewSvg = `<svg width="400" height="400" xmlns="http://www.w3.org/2000/svg">
      <rect width="400" height="400" fill="#1a1a1a"/>
      <rect x="150" y="150" width="100" height="100" fill="#3b82f6" stroke="#60a5fa" stroke-width="2"/>
      <text x="200" y="320" text-anchor="middle" fill="#9ca3af" font-family="Arial" font-size="14">3D Model Preview</text>
      <text x="200" y="340" text-anchor="middle" fill="#6b7280" font-family="Arial" font-size="12">${prompt}</text>
    </svg>`;
    
    const modelFile = new Blob([objContent], { type: 'text/plain' });
    const previewImage = new Blob([previewSvg], { type: 'image/svg+xml' });

    // Сохраняем файлы
    const modelFileName = `${modelId}.obj`;
    const previewFileName = `${modelId}_preview.svg`;
    
    const modelPath = path.join(modelDir, modelFileName);
    const previewPath = path.join(modelDir, previewFileName);

    // Конвертируем Blob в Buffer для сохранения
    const modelBuffer = Buffer.from(await modelFile.arrayBuffer());
    const previewBuffer = Buffer.from(await previewImage.arrayBuffer());

    await writeFile(modelPath, modelBuffer);
    await writeFile(previewPath, previewBuffer);

    // Создаем URL для доступа к файлам
    const modelUrl = `/models/${modelId}/${modelFileName}`;
    const previewUrl = `/models/${modelId}/${previewFileName}`;

    // Временно сохраняем метаданные (в реальном проекте это будет в БД)
    const metadata = {
      id: modelId,
      title: prompt,
      prompt: enhancedPrompt,
      author: 'Anonymous',
      fileUrl: modelUrl,
      previewImageUrl: previewUrl,
      isPublic: false,
      likes: 0,
      downloads: 0,
      fileSize: `${Math.round(modelBuffer.length / 1024)} KB`,
      formats: ['OBJ'],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    const metadataPath = path.join(modelDir, 'metadata.json');
    await writeFile(metadataPath, JSON.stringify(metadata, null, 2));

    console.log(`3D model generated successfully: ${modelId}`);

    return NextResponse.json({
      success: true,
      data: {
        modelId,
        fileUrl: modelUrl,
        previewUrl: previewUrl,
        metadata
      }
    });

  } catch (error) {
    console.error('Error generating 3D model:', error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Неизвестная ошибка при генерации' 
      },
      { status: 500 }
    );
  }
}